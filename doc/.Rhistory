fit2 <- svm(x.train, y.train, type = "C", scale = FALSE, kernel = "radial", gamma = param.optimal[2], cost = param.optimal[1])
yfit2 <- predict(fit2, x.test)
mis.rate2 <- mean(yfit2 != y.test)
mis.rate2
fit2 <- svm(x.train, y.train, type = "C", scale = FALSE, kernel = "radial", gamma = param.optimal[2], cost = param.optimal[1])
yfit2 <- predict(fit2, x.test)
mis.rate2 <- mean(yfit2 != y.test)
mis.rate2
plot(c, error1, type = "l", col = 10)
c
error1
c <- seq(from = 0.002, to = 0.06, by = 0.002))
c <- seq(from = 0.002, to = 0.06, by = 0.002)
c
c.optimal
c
zip.5 <- read.table("train.5.txt", header = FALSE, sep = ",")
zip.5 <- as.matrix(zip.5)
zip.6 <- read.table("train.6.txt", header = FALSE, sep = ",")
zip.6 <- as.matrix(zip.6)
n.5 <- nrow(zip.5)
n.6 <- nrow(zip.6)
# Divide test data
test5 <- sample(n.5, round(size = 0.2*n.5))
test6 <- sample(n.6, round(size = 0.2*n.6))
x.train <- rbind(zip.5[-test5,], zip.6[-test6,])
y.train <- c(rep(-1,n.5-length(test5)),rep(1,n.6-length(test6)))
x.test <- rbind(zip.5[test5,], zip.6[test6,])
y.test <- c(rep(-1,length(test5)),rep(1,length(test6)))
# Linear SVM
library(e1071)
c <- seq(from = 0.002, to = 0.06, by = 0.002)
k <- 5
nums <- rep(1:k, each = nrow(x.train)/k)
fold <- sample(nums)
error1 <- rep(NA,length(c))
for (i in 1:length(c)){
fold.error <- rep(NA,k)
for (j in 1:k){
xtest <- x.train[fold == j,]
ytest <- y.train[fold == j]
xtrain <- x.train[fold != j, ]
ytrain <- y.train[fold != j]
fit <- svm(xtrain, ytrain, scale = FALSE, type = "C", kernel = "linear", cost = c[i])
y.fit <- predict(fit, xtest)
fold.error[j] <- mean(y.fit != ytest)
}
error1[i] <- mean(fold.error)
}
c.optimal <- c[which.min(error1)]
c.optimal
plot(c, error1, type = "l", col = 10)
fit1 <- svm(x.train, y.train, scale = FALSE, type = "C", kernel = "linear", cost = c.optimal)
yfit1 <- predict(fit1, x.test)
mis.rate1 <- mean(yfit1 != y.test)
mis.rate1
fit2 <- svm(x.train, y.train, type = "C", scale = FALSE, kernel = "radial", gamma = param.optimal[2], cost = param.optimal[1])
yfit2 <- predict(fit2, x.test)
mis.rate2 <- mean(yfit2 != y.test)
mis.rate2
error2.mat <- matrix(error2, nrow = length(c2))
colnames(error2.mat) <- c2
row.names(error2.mat) <- gamma
heatmap(error2.mat, Rowv=NA, Colv=NA, col = cm.colors(256), scale="column", labRow = FALSE, labCol = FALSE, xlab = "cost", ylab = "gamma", margins=c(5,10))
param.optimal
error2.mat
c2
gamma
c <- seq(from = 0.001, to = 0.111, by = 0.01)
k <- 5
nums <- rep(1:k, each = nrow(x.train)/k)
fold <- sample(nums)
error1 <- rep(NA,length(c))
for (i in 1:length(c)){
fold.error <- rep(NA,k)
for (j in 1:k){
xtest <- x.train[fold == j,]
ytest <- y.train[fold == j]
xtrain <- x.train[fold != j, ]
ytrain <- y.train[fold != j]
fit <- svm(xtrain, ytrain, scale = FALSE, type = "C", kernel = "linear", cost = c[i])
y.fit <- predict(fit, xtest)
fold.error[j] <- mean(y.fit != ytest)
}
error1[i] <- mean(fold.error)
}
c.optimal <- c[which.min(error1)]
c.optimal
plot(c, error1, type = "l", col = 10)
y.fit
zip.5 <- read.table("train.5.txt", header = FALSE, sep = ",")
zip.5 <- as.matrix(zip.5)
zip.6 <- read.table("train.6.txt", header = FALSE, sep = ",")
zip.6 <- as.matrix(zip.6)
n.5 <- nrow(zip.5)
n.6 <- nrow(zip.6)
# Divide test data
test5 <- sample(n.5, round(size = 0.2*n.5))
test6 <- sample(n.6, round(size = 0.2*n.6))
x.train <- rbind(zip.5[-test5,], zip.6[-test6,])
y.train <- c(rep(-1,n.5-length(test5)),rep(1,n.6-length(test6)))
x.test <- rbind(zip.5[test5,], zip.6[test6,])
y.test <- c(rep(-1,length(test5)),rep(1,length(test6)))
# Linear SVM
library(e1071)
c <- seq(from = 0.001, to = 0.111, by = 0.01)
k <- 5
nums <- rep(1:k, each = nrow(x.train)/k)
fold <- sample(nums)
error1 <- rep(NA,length(c))
for (i in 1:length(c)){
fold.error <- rep(NA,k)
for (j in 1:k){
xtest <- x.train[fold == j,]
ytest <- y.train[fold == j]
xtrain <- x.train[fold != j, ]
ytrain <- y.train[fold != j]
fit <- svm(xtrain, ytrain, scale = FALSE, type = "C", kernel = "linear", cost = c[i])
y.fit <- predict(fit, xtest)
fold.error[j] <- mean(y.fit != ytest)
}
error1[i] <- mean(fold.error)
}
c.optimal <- c[which.min(error1)]
c.optimal
error1
plot(c, error1, type = "l", col = 10)
exp(-5)
exp(-1)
exp(-2)
c <- exp(seq(from = -8, to = -2, by = 0.5))
k <- 5
nums <- rep(1:k, each = nrow(x.train)/k)
fold <- sample(nums)
error1 <- rep(NA,length(c))
for (i in 1:length(c)){
fold.error <- rep(NA,k)
for (j in 1:k){
xtest <- x.train[fold == j,]
ytest <- y.train[fold == j]
xtrain <- x.train[fold != j, ]
ytrain <- y.train[fold != j]
fit <- svm(xtrain, ytrain, scale = FALSE, type = "C", kernel = "linear", cost = c[i])
y.fit <- predict(fit, xtest)
fold.error[j] <- mean(y.fit != ytest)
}
error1[i] <- mean(fold.error)
}
c.optimal <- c[which.min(error1)]
c.optimal
error1
plot(c, error1, type = "l", col = 10)
plot(c, error1, type = "l", col = 10)
fit2 <- svm(x.train, y.train, type = "C", scale = FALSE, kernel = "radial", gamma = param.optimal[2], cost = param.optimal[1])
yfit2 <- predict(fit2, x.test)
mis.rate2 <- mean(yfit2 != y.test)
mis.rate2
param.optimal
yfit2
y.test
fit1
x.train
fit2 <- svm(x.train, y.train, type = "C", scale = FALSE, kernel = "radial", gamma = param.optimal[2], cost = param.optimal[1])
yfit2 <- predict(fit2, x.test)
mis.rate2 <- mean(yfit2 != y.test)
mis.rate2
zip.5 <- as.matrix(zip.5)
zip.6 <- read.table("train.6.txt", header = FALSE, sep = ",")
zip.6 <- as.matrix(zip.6)
n.5 <- nrow(zip.5)
n.6 <- nrow(zip.6)
# Divide test data
test5 <- sample(n.5, round(size = 0.2*n.5))
test6 <- sample(n.6, round(size = 0.2*n.6))
x.train <- rbind(zip.5[-test5,], zip.6[-test6,])
y.train <- c(rep(-1,n.5-length(test5)),rep(1,n.6-length(test6)))
x.test <- rbind(zip.5[test5,], zip.6[test6,])
y.test <- c(rep(-1,length(test5)),rep(1,length(test6)))
fit2 <- svm(x.train, y.train, type = "C", scale = FALSE, kernel = "radial", gamma = param.optimal[2], cost = param.optimal[1])
yfit2 <- predict(fit2, x.test)
mis.rate2 <- mean(yfit2 != y.test)
mis.rate2
plot(c, error1, type = "l", col = 10)
exp(3.87)
exp(-3.87)
exp(-3.87)*3.87
exp(-3.87)*3.87^2/2
exp(-3.87)*3.87^3/6
exp(-3.87)*3.87^4/24
exp(-3.87)*3.87^5/120
exp(-3.87)*3.87^6/120/6
exp(-3.87)*3.87^7/120/6/7
exp(-3.87)*3.87^8/120/6/7/8
exp(-3.87)*3.87^9/120/6/7/8/9
exp(-3.87)*3.87^10/120/6/7/8/9/10
1-0.02086-0.08072-0.1562-0.20149-0.19495-0.15089-0.09732-0.05380-0.02603-0.01119-0.00433
exp(-3.87)*3.87^11/120/6/7/8/9/10/11
57+203+383+525+532+408+273+139+45+27+10+6
(57/2608-0.02086)^2/0.02086
(203/2608-0.08072)^2/0.08072
(383/2608-0.1562)^2/0.1562
x<-seq(from=0,to=11,by=1)
x
y<-exp(-3.87)*3.87^x/factorial(x)
y
y[12]
y[12] <- 0.00222
sum(y)
y
k <- c(57,203,383,525,532,408,273,139,45,27,10,6)
y
k
sum((k/2608-y)^2/y)
sum((k/2608-y)^2/y)*2608
1-pchisq(12.97365,df=11)
data <- read.csv("output/dtm+stm.csv")
library(caret)
data$Sentiment <- as.factor(data$Sentiment)
set.seed(12)
# balanced partition
test.index <- createDataPartition(data$Sentiment, p = 0.2, list = F)
test <- data[test.index,]
train <- data[-test.index,]
data_splitted <- list(train = train, test = test)
head(test)
test.index
dim(test)
dim(train)
write.csv(test, "test.csv")
write.csv(train, "train.csv")
head(test)
head(train)
dim(data)
knitr::opts_chunk$set(echo = TRUE)
sales <- read.csv("Salespeople.csv")
head(sales)
if(!require("EBImage")){
source("https://bioconductor.org/biocLite.R")
biocLite("EBImage")
}
if(!require("gbm")){
install.packages("gbm")
}
library("EBImage")
library("gbm")
if(!require("EBImage")){
source("https://bioconductor.org/biocLite.R")
biocLite("EBImage")
}
if(!require("gbm")){
install.packages("gbm")
}
library("EBImage")
library("gbm")
set.seed(2018)
setwd("../doc")
# here replace it with your own path or manually set it in RStudio to where this rmd file is located.
# use relative path for reproducibility
train_dir <- "../data/train_set/" # This will be modified for different data sets.
train_LR_dir <- paste(train_dir, "LR/", sep="")
train_HR_dir <- paste(train_dir, "HR/", sep="")
train_label_path <- paste(train_dir, "label.csv", sep="")
run.cv=TRUE # run cross-validation on the training set
K <- 3  # number of CV folds
run.feature.train=TRUE # process features for training set
run.test=TRUE # run evaluation on an independent test set
run.feature.test=TRUE # process features for test set
model_values <- seq(2, 5, 1)
model_labels = paste("GBM with depth =", model_values)
extra_label <- read.csv(train_label_path, colClasses=c("NULL", NA, NA))
load("../output/feature_train.RData")
source("../lib/train.R")
source("../lib/test.R")
feat_train <- dat_train$feature
label_train <- dat_train$label
label_train
feat_train
source("../lib/train.R")
source("../lib/test.R")
par_best <- list(depth=4)
tm_train=NA
tm_train <- system.time(fit_train <- train(feat_train, label_train, par_best))
save(fit_train, file="../output/fit_train.RData")
test_dir <- "../data/test_set/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
imgLR <- readImage(paste0(test_LR_dir,  "img", "_", sprintf("%04d", i), ".jpg"))
pathHR <- paste0(test_HR_dir,  "img", "_", sprintf("%04d", i), ".jpg")
featMat <- array(NA, c(dim(imgLR)[1] * dim(imgLR)[2], 8, 3))
imgLR <- readImage(paste0(test_LR_dir,  "img", "_", sprintf("%04d", 1), ".jpg"))
pathHR <- paste0(test_HR_dir,  "img", "_", sprintf("%04d", 1), ".jpg")
featMat <- array(NA, c(dim(imgLR)[1] * dim(imgLR)[2], 8, 3))
setwd("D:/GitHub/Fall2018-Proj3-Sec2-grp3/doc")
imgLR <- readImage(paste0(test_LR_dir,  "img", "_", sprintf("%04d", 1), ".jpg"))
pathHR <- paste0(test_HR_dir,  "img", "_", sprintf("%04d", 1), ".jpg")
featMat <- array(NA, c(dim(imgLR)[1] * dim(imgLR)[2], 8, 3))
width_LR <- dim(imgLR)[1]
height_LR <- dim(imgLR)[2]
padded_image_LR <- array(0, c(width_LR+2, height_LR+2, 3))
padded_image_LR[2:(width_LR + 1), 2:(height_LR+1), ] = imgLR[,,]
for(j in 1:width_LR * height_LR){
row_LR <- floor((j - 1)/height_LR + 1)
col_LR <- (j - 1) %% height_LR + 1
featMat[j, , ] <- apply(padded_image_LR[row_LR:(row_LR+2), col_LR:(col_LR+2), ], 3, extract_feat)
}
source("../lib/extract_feat.R")
width_LR <- dim(imgLR)[1]
height_LR <- dim(imgLR)[2]
padded_image_LR <- array(0, c(width_LR+2, height_LR+2, 3))
padded_image_LR[2:(width_LR + 1), 2:(height_LR+1), ] = imgLR[,,]
for(j in 1:width_LR * height_LR){
row_LR <- floor((j - 1)/height_LR + 1)
col_LR <- (j - 1) %% height_LR + 1
featMat[j, , ] <- apply(padded_image_LR[row_LR:(row_LR+2), col_LR:(col_LR+2), ], 3, extract_feat)
}
predMat <- test(modelList, featMat)
predMat <- test(fit_train, featMat)
predMat
height_HR <- 2*height_LR
width_HR <- 2*width_LR
img_HR_pred <- array(NA, c(width_HR, height_HR, 3))
dim(img_HR_pred)
568*430*3
mean(predMat)
100%%10
floor(1/2)
floor(2/2)
padded_image_LR[1:2,1:2,]
as.numeric(padded_image_LR[1:2,1:2,])
as.numeric(padded_image_LR[2:3,2:3,])
padded_image_LR[2:3,2:3,]
array(as.numeric(padded_image_LR[2:3,2:3,]), dim=c(2,2,3))
height_HR <- 2*height_LR
width_HR <- 2*width_LR
img_HR_pred <- array(predMat, dim=c(width_HR, height_HR, 3))
for(j in 1:height_HR*width_HR){
row_HR <- floor((j - 1)/height_HR + 1)
row_LR_j <- floor((row_HR+1)/2)
col_HR <- (j - 1) %% height_HR + 1
col_LR_j <- floor((row_LR+1)/2)
img_pred[row_HR, col_HR,] <- img_HR_pred[row_HR, col_HR,] + imgLR[row_LR_j, col_LR_j,]
}
img_pred <- array(NA, dim=c(width_HR, height_HR, 3))
for(j in 1:height_HR*width_HR){
row_HR <- floor((j - 1)/height_HR + 1)
row_LR_j <- floor((row_HR+1)/2)
col_HR <- (j - 1) %% height_HR + 1
col_LR_j <- floor((row_LR+1)/2)
img_pred[row_HR, col_HR,] <- img_HR_pred[row_HR, col_HR,] + imgLR[row_LR_j, col_LR_j,]
}
img_display <- Image(img_pred)
display(img_display)
img_pred
for(j in 1:height_HR*width_HR){
print(j)
row_HR <- floor((j - 1)/height_HR + 1)
row_LR_j <- floor((row_HR+1)/2)
col_HR <- (j - 1) %% height_HR + 1
col_LR_j <- floor((row_LR+1)/2)
img_pred[row_HR, col_HR,] <- img_HR_pred[row_HR, col_HR,] + imgLR[row_LR_j, col_LR_j,]
}
img_display <- Image(img_pred)
display(img_display)
for(j in 1:(height_HR*width_HR)){
print(j)
row_HR <- floor((j - 1)/height_HR + 1)
row_LR_j <- floor((row_HR+1)/2)
col_HR <- (j - 1) %% height_HR + 1
col_LR_j <- floor((row_LR+1)/2)
img_pred[row_HR, col_HR,] <- img_HR_pred[row_HR, col_HR,] + imgLR[row_LR_j, col_LR_j,]
}
for(j in 1:(height_HR*width_HR)){
row_HR <- floor((j - 1)/height_HR + 1)
row_LR_j <- floor((row_HR+1)/2)
col_HR <- (j - 1) %% height_HR + 1
col_LR_j <- floor((row_LR+1)/2)
img_pred[row_HR, col_HR,] <- img_HR_pred[row_HR, col_HR,] + imgLR[row_LR_j, col_LR_j,]
}
a <- padded_image_LR[1:3, 1:3, ]
a
rep(a,2)
?rep
for(j in 1:(height_HR*width_HR)){
row_HR <- floor((j - 1)/height_HR + 1)
row_LR_j <- floor((row_HR+1)/2)
col_HR <- (j - 1) %% height_HR + 1
col_LR_j <- floor((row_LR+1)/2)
img_pred[row_HR, col_HR,] <- img_HR_pred[row_HR, col_HR,] + imgLR[row_LR_j, col_LR_j,]
}
m[rep(1:nrow(m), times = v), ]
a
a[rep(1:3, times = 2),, ]
a[rep(1:3, times = c(2,2,2)),, ]
rep(2,3)
imgLR
imgLR[rep(1:height_LR, times = rep(2,height_LR)),,]
width_HR <- 2*width_LR
img_HR_pred <- array(predMat, dim=c(width_HR, height_HR, 3))
img_center <- imageData(imgLR[rep(1:height_LR, times = rep(2,height_LR)),,])
img_center <- imageData(img_center[rep(1:width_LR, times = rep(2,width_LR)),,])
dim(img_center)
dim(img_HR_pred)
width_HR <- 2*width_LR
img_HR_pred <- array(predMat, dim=c(width_HR, height_HR, 3))
img_center <- imageData(imgLR[rep(1:height_LR, times = rep(2,height_LR)),,])
img_center <- img_center[,rep(1:width_LR, times = rep(2,width_LR)),]
img_center
width_LR
dim(predMat)
height_LR
width_LR
img_HR_pred <- array(predMat, dim=c(width_HR, height_HR, 3))
img_center <- imageData(imgLR[rep(1:width_LR, times = rep(2, width_LR)),,])
img_center <- img_center[, rep(1:height_LR, times = rep(2, height_LR)),]
img_pred <- img_HR_pred + img_center
img_center
dim(img_center)
dim(img_HR_pred)
img_display <- Image(img_pred)
display(img_display)
imgHR <- readImage(pathHR)
mse <- sum((imgHR - img_HR_pred )^2)/(3*height_HR*width_HR)
psnr <- 20*log(255) - 10*log(mse)
mse
psnr
cat("Time for constructing training features=", tm_feature_train[1], "s \n")
cat("Time for constructing testing features=", tm_feature_test[1], "s \n")
cat("Time for training model=", tm_train[1], "s \n")
cat("Time for super-resolution=", tm_test[1], "s \n")
source("../lib/superResolution.R")
test_dir <- "../data/test_set/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
img_display
writeImage(img_display, paste0(HR_dir,  "img_pred", "_", sprintf("%04d", 1), ".jpg"))
writeImage(img_display, paste0(test_HR_dir,  "img_pred", "_", sprintf("%04d", 1), ".jpg"))
imgHR <- readImage(pathHR)
mse <- sum((imgHR - img_HR_pred )^2)/(3*height_HR*width_HR)
if (i==1){
psnr <- 20*log(255) - 10*log(mse)
} else {
psnr <- c(psnr, 20*log(255) - 10*log(mse))
}
}
source("../lib/superResolution.R")
test_dir <- "../data/test_set/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
if(run.test){
# load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
if(run.test){
# load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
source("../lib/superResolution.R")
test_dir <- "../data/test_set/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
if(run.test){
# load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
source("../lib/superResolution.R")
if(run.test){
# load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
if(run.test){
# load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
20*log(255)-120
10^(-0.91)
tm_test=NA
if(run.test){
# load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
source("../lib/superResolution.R")
test_dir <- "../data/test_set/" # This will be modified for different data sets.
test_LR_dir <- paste(test_dir, "LR/", sep="")
test_HR_dir <- paste(test_dir, "HR/", sep="")
tm_test=NA
if(run.test){
# load(file="../output/fit_train.RData")
tm_test <- system.time(superResolution(test_LR_dir, test_HR_dir, fit_train))
}
tm_test
psnr
mean
mse
source("../lib/superResolution.R")
tm_test=NA
if(run.test){
# load(file="../output/fit_train.RData")
tm_test <- system.time(result <- superResolution(test_LR_dir, test_HR_dir, fit_train))
}
result
